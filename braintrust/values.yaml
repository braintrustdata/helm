# Global configs
global:
  orgName: "<your org name on Braintrust>"
  # When createNamespace is true, the namespace will be created and resources will be in global.namespace
  # When createNamespace is false, resources will use .Release.Namespace (the namespace specified during helm install/upgrade)
  createNamespace: false
  namespace: "braintrust"
  namespaceAnnotations: {}
  labels: {}
  # Control plane telemetry configuration (applies to both API and Brainstore)
  # Available options (comma-separated):
  #   - status: Health check information (default)
  #   - metrics: System metrics (CPU/memory) and Braintrust-specific metrics like indexing lag (default)
  #   - usage: Billing usage telemetry for aggregate usage metrics
  #   - memprof: Memory profiling statistics and heap usage patterns
  #   - logs: Application logs
  #   - traces: Distributed tracing data
  # NOTE: If you previously configured BRAINSTORE_CONTROL_PLANE_TELEMETRY or CONTROL_PLANE_TELEMETRY
  # as extraEnvVars, you can remove those entries and use this global setting instead.
  # ExtraEnvVars values will override this global setting if both are present.
  controlPlaneTelemetry: "status,metrics,usage"

# Cloud provider configuration
cloud: ""  # "google" or "azure" or "aws"

# Optional: Google Cloud specific configuration
google:
  # GKE mode: "autopilot" or "standard"
  # When "autopilot": Automatically configures node selectors for local SSDs
  # When "standard": Uses default emptyDir (assumes nodes have local SSDs if configured)
  mode: "autopilot"  # Set to "autopilot" for GKE Autopilot and "standard" for GKE with manual node pools
  # Machine family for Autopilot mode (used when mode is "autopilot") Must be a machine family that supports local SSDs
  autopilotMachineFamily: "c4"

azure:
  tenantId: ""
  # Automatically configures NVMe temporary disks into a single RAID0 volume. It should always be enabled except in rare cases.
  # https://learn.microsoft.com/en-us/azure/storage/container-storage/container-storage-introduction
  enableAzureContainerStorageDriver: true
  # Azure Key Vault driver configuration for syncing secrets from Azure Key Vault
  enableAzureKeyVaultDriver: true
  # This is the client ID of the service principal that has access to the keyvault.
  keyVaultCSIclientID: ""
  # This should come from the terraform module
  keyVaultName: ""


objectStorage:
  # Azure specific configuration
  azure:
    # This should come from the terraform module
    storageAccountName: ""
    # These are the default container names used by the terraform module
    brainstoreContainer: "brainstore"
    responseContainer: "responses"
    codeBundleContainer: "code-bundles"

  # AWS specific configuration
  aws:
    # This should come from the terraform module
    brainstoreBucket: ""
    responseBucket: ""
    codeBundleBucket: ""

  google:
    # This should come from the terraform module
    brainstoreBucket: ""
    # Single API bucket with paths for responses and code bundles
    apiBucket: ""

api:
  name: "braintrust-api"
  labels: {}
  podLabels: {}
  annotations:
    configmap: {}
    deployment: {}
    service: {}
    pod: {}
    serviceaccount: {}
  replicas: 2
  image:
    repository: public.ecr.aws/braintrust/standalone-api
    tag: v1.1.31
    pullPolicy: IfNotPresent
  service:
    # Optional name for service object. If not specified (empty), the api.name
    # is used.
    name: ""
    type: ClusterIP
    port: 8000
    portName: http
  serviceAccount:
    name: "braintrust-api"
    awsRoleArn: ""
    azureClientId: ""
    googleServiceAccount: ""
  # Enable native GCS authentication via workload identity (defaults to false for S3-compatible access)
  enableGcsAuth: false
  resources:
    requests:
      cpu: "2"
      memory: "4Gi"
    limits:
      cpu: "4"
      memory: "8Gi"
  # Allow running user generated code functions (e.g. scorers/tools)
  allowCodeFunctionExecution: true
  # Brainstore backfill configuration. These defaults are fine for most cases.
  backfillDisableHistorical: false
  backfillDisableNonhistorical: false
  allowInvalidBase64: false  # By default, we will error on invalid base64 strings. Setting this to true will allow invalid base64 strings to be processed.
  nodeMemoryPercent: "80"
  extraEnvVars:
    # Example:
    # - name: MY_ENV_VAR
    #   value: "my-value"
    # - name: ANOTHER_VAR
    #   value: "another-value"
  nodeSelector: {}
  tolerations: []
  affinity: {}
  # Health check probes
  livenessProbe:
    httpGet:
      path: /
      port: 8000
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  readinessProbe:
    httpGet:
      path: /status
      port: 8001
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
    successThreshold: 1
  # Health server configuration
  healthServer:
    host: "0.0.0.0"
    port: "8001"

# Brainstore configuration (split into reader and writer)
brainstore:
  # Shared configuration
  labels: {}
  serviceAccount:
    name: "brainstore"
    awsRoleArn: ""
    azureClientId: ""
    googleServiceAccount: ""
    annotations: {}
  # Shared image configuration
  image:
    repository: public.ecr.aws/braintrust/brainstore
    tag: v1.1.31
    pullPolicy: IfNotPresent
  # Locks backend configuration
  # Options: "redis" (default) or "objectStorage"
  # When "redis": Uses Redis for distributed locks (REDIS_URL must be configured in secrets)
  # When "objectStorage": Uses cloud object storage for distributed locks
  # WARNING: If you have an existing deployment, DO NOT change this setting.
  # Changing the locks backend on an existing deployment could cause data corruption at this time.
  locksBackend: "redis"
  # Health check probes (applies to both reader and writer)
  livenessProbe:
    httpGet:
      path: /
      port: 4000
    initialDelaySeconds: 60
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  readinessProbe:
    httpGet:
      path: /status
      port: 4000
    initialDelaySeconds: 30
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
    successThreshold: 1

  # Brainstore Reader configuration
  reader:
    name: "brainstore-reader"
    labels: {}
    podLabels: {}
    annotations:
      configmap: {}
      deployment: {}
      service: {}
      pod: {}
    replicas: 2
    service:
      name: ""
      type: ClusterIP
      port: 4000
      portName: http
    resources:
      requests:
        cpu: "4"
        memory: "8Gi"
      limits:
        cpu: "8"
        memory: "16Gi"
    cacheDir: "/mnt/tmp/brainstore"
    objectStoreCacheMemoryLimit: "1Gi"
    objectStoreCacheFileSize: "50Gi"
    verbose: true
    # Optional: Volume configuration for cache storage
    # When not set, uses default emptyDir: {} (backward compatible)
    volume:
      # Storage size for ephemeral storage requests (used with GKE Autopilot local SSDs)
      size: ""
    extraEnvVars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}

  # Brainstore Writer configuration
  writer:
    name: "brainstore-writer"
    labels: {}
    podLabels: {}
    annotations:
      configmap: {}
      deployment: {}
      service: {}
      pod: {}
    replicas: 1
    service:
      name: ""
      type: ClusterIP
      port: 4000
      portName: http
    resources:
      requests:
        cpu: "8"
        memory: "16Gi"
      limits:
        cpu: "16"
        memory: "32Gi"
    cacheDir: "/mnt/tmp/brainstore"
    objectStoreCacheMemoryLimit: "1Gi"
    objectStoreCacheFileSize: "50Gi"
    verbose: true
    # Optional: Volume configuration for cache storage
    # When not set, uses default emptyDir: {} (backward compatible)
    volume:
      # Storage size for ephemeral storage requests
      # Used with GKE Autopilot local SSDs and Azure Container Storage CSI
      size: ""
    extraEnvVars: []
    # Example:
    # - name: MY_ENV_VAR
    #   value: "my-value"
    # - name: ANOTHER_VAR
    #   value: "another-value"
    nodeSelector: {}
    tolerations: []
    affinity: {}

azureKeyVaultDriver:
  # Map your Key Vault secret names to the required Kubernetes secret keys
  # Example: If your Redis URL is stored as "my-redis-connection" in Key Vault, set:
  #   keyVaultSecretName: "my-redis-connection"
  #   kubernetesSecretKey: "REDIS_URL"
  # These defaults assume you are using the Braintrust terraform module to deploy the base infrastructure
  secrets:
    - keyVaultSecretName: "redis-connection-string"
      keyVaultSecretType: "secret"
      kubernetesSecretKey: "REDIS_URL"
    - keyVaultSecretName: "postgres-connection-string"
      kubernetesSecretKey: "PG_URL"
      keyVaultSecretType: "secret"
    - keyVaultSecretName: "brainstore-license-key"
      keyVaultSecretType: "secret"
      kubernetesSecretKey: "BRAINSTORE_LICENSE_KEY"
    - keyVaultSecretName: "function-secret-key"
      keyVaultSecretType: "secret"
      kubernetesSecretKey: "FUNCTION_SECRET_KEY"
    - keyVaultSecretName: "azure-storage-connection-string"
      keyVaultSecretType: "secret"
      kubernetesSecretKey: "AZURE_STORAGE_CONNECTION_STRING"

# Istio VirtualService configuration (optional)
# Enable this to create an Istio VirtualService for the API
virtualService:
  enabled: false
  name: ""  # If empty, defaults to "<api.name>-vs"
  labels: {}
  annotations: {}
  # List of gateway names (can include namespace, e.g., "istio-ingress/asm-gateway")
  gateways:
    - "istio-gateway"
  # List of hosts/domains
  hosts:
    - "braintrust.example.com"
  # HTTP routing rules
  # The destination host will use api.service.name (or api.name if service.name is empty)
  # The destination port will use api.service.port (default: 8000)
  http:
    - match:
        - uri:
            prefix: "/"
      route:
        - destination:
            host: "braintrust-api"  # Should match api.service.name or api.name
            port:
              number: 8000  # Should match api.service.port