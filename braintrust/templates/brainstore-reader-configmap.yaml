---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Values.brainstore.reader.name }}
  namespace: {{ include "braintrust.namespace" . }}
  {{- with (merge .Values.global.labels .Values.brainstore.reader.labels) }}
  labels:
    {{- toYaml . | nindent 4 }}
  {{- end }}
  {{- with .Values.brainstore.reader.annotations.configmap }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
data:
  BRAINSTORE_READER_ONLY_MODE: "true"
  BRAINSTORE_VERBOSE: {{ (or (eq (toString .Values.brainstore.reader.verbose) "true") (eq (toString .Values.brainstore.reader.verbose) "1")) | ternary "1" "0" | quote }}
  BRAINSTORE_PORT: {{ .Values.brainstore.reader.service.port | quote }}
  BRAINSTORE_CACHE_DIR: {{ .Values.brainstore.reader.cacheDir | quote }}
  BRAINSTORE_OBJECT_STORE_CACHE_MEMORY_LIMIT: {{ .Values.brainstore.reader.objectStoreCacheMemoryLimit | quote }}
  BRAINSTORE_OBJECT_STORE_CACHE_FILE_SIZE: {{ .Values.brainstore.reader.objectStoreCacheFileSize | quote }}
  {{- if eq .Values.cloud "azure" }}
  # See here for reference:
  # https://docs.rs/object_store/latest/object_store/azure/struct.MicrosoftAzureBuilder.html
  AZURE_STORAGE_ACCOUNT_NAME: {{ .Values.objectStorage.azure.storageAccountName | quote }}
  # This will create odd paths like az://brainstore/brainstore/index, but it maintains the naming and prefix conventions
  # with AWS and avoids confusion with env vars.
  BRAINSTORE_INDEX_URI: "az://{{ .Values.objectStorage.azure.brainstoreContainer }}/brainstore/index"
  BRAINSTORE_REALTIME_WAL_URI: "az://{{ .Values.objectStorage.azure.brainstoreContainer }}/brainstore/wal"
  {{- if eq .Values.brainstore.locksBackend "objectStorage" }}
  BRAINSTORE_LOCKS_URI: "az://{{ .Values.objectStorage.azure.brainstoreContainer }}/brainstore/locks"
  {{- end }}
  {{- else if eq .Values.cloud "aws" }}
  BRAINSTORE_INDEX_URI: "s3://{{ .Values.objectStorage.aws.brainstoreBucket }}/brainstore/index"
  BRAINSTORE_REALTIME_WAL_URI: "s3://{{ .Values.objectStorage.aws.brainstoreBucket }}/brainstore/wal"
  {{- if eq .Values.brainstore.locksBackend "objectStorage" }}
  BRAINSTORE_LOCKS_URI: "s3://{{ .Values.objectStorage.aws.brainstoreBucket }}/brainstore/locks"
  {{- end }}
  {{- else if eq .Values.cloud "google" }}
  BRAINSTORE_INDEX_URI: "gs://{{ .Values.objectStorage.google.brainstoreBucket }}/brainstore/index"
  BRAINSTORE_REALTIME_WAL_URI: "gs://{{ .Values.objectStorage.google.brainstoreBucket }}/brainstore/wal"
  {{- if eq .Values.brainstore.locksBackend "objectStorage" }}
  BRAINSTORE_LOCKS_URI: "gs://{{ .Values.objectStorage.google.brainstoreBucket }}/brainstore/locks"
  {{- end }}
  {{- end }}
  BRAINSTORE_CONTROL_PLANE_TELEMETRY: {{ .Values.global.controlPlaneTelemetry | quote }}
  NO_COLOR: "1"

  # TTL wrapper script for automatic time-based pod restarts
  ttl-wrapper.sh: |
    #!/bin/sh
    # Time-based pod restart wrapper
    # This script wraps the application process and terminates it after a configured TTL

    set -e

    # Configuration from environment variables
    TTL_ENABLED="${POD_TTL_ENABLED:-false}"
    BASE_TTL_SECONDS="${POD_BASE_TTL_SECONDS:-259200}"  # Default 72 hours
    RANDOM_RANGE_SECONDS="${POD_RANDOM_RANGE_SECONDS:-21600}"  # Default ±6 hours

    # Exit immediately if TTL is disabled
    if [ "$TTL_ENABLED" != "true" ]; then
        echo "[TTL-WRAPPER] TTL disabled, executing command directly: $@"
        exec "$@"
    fi

    # Calculate pod-specific TTL with randomization
    calculate_ttl() {
        local pod_name="${HOSTNAME:-unknown}"
        local current_time=$(date +%s)

        # Hash pod name to get consistent offset (using cksum as it's more portable than sha256sum)
        local pod_hash=$(echo "$pod_name" | cksum | awk '{print $1}')
        local pod_offset=$((pod_hash % RANDOM_RANGE_SECONDS))

        # Add startup time component for additional entropy
        local startup_offset=$((current_time % RANDOM_RANGE_SECONDS))

        # Combine offsets and center around zero
        local combined_offset=$(( (pod_offset + startup_offset) % RANDOM_RANGE_SECONDS ))
        local centered_offset=$((combined_offset - (RANDOM_RANGE_SECONDS / 2)))

        # Calculate final TTL
        local ttl=$((BASE_TTL_SECONDS + centered_offset))
        echo "$ttl"
    }

    # Format seconds to human-readable duration
    format_duration() {
        local seconds=$1
        local hours=$((seconds / 3600))
        local minutes=$(( (seconds % 3600) / 60 ))
        echo "${hours}h ${minutes}m"
    }

    TTL=$(calculate_ttl)
    TTL_HUMAN=$(format_duration $TTL)
    RESTART_TIME=$(date -d "@$(($(date +%s) + TTL))" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || date -r $(($(date +%s) + TTL)) '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "in $TTL_HUMAN")

    echo "[TTL-WRAPPER] Pod: ${HOSTNAME:-unknown}"
    echo "[TTL-WRAPPER] Base TTL: $(format_duration $BASE_TTL_SECONDS)"
    echo "[TTL-WRAPPER] Random range: ±$(format_duration $((RANDOM_RANGE_SECONDS / 2)))"
    echo "[TTL-WRAPPER] Calculated TTL: $TTL_HUMAN ($TTL seconds)"
    echo "[TTL-WRAPPER] Scheduled restart: $RESTART_TIME"
    echo "[TTL-WRAPPER] Starting application: $@"

    # Start the application in the background
    "$@" &
    APP_PID=$!

    echo "[TTL-WRAPPER] Application started with PID $APP_PID"

    # Trap signals to forward to application
    trap "echo '[TTL-WRAPPER] Received signal, forwarding to application'; kill -TERM $APP_PID 2>/dev/null || true; wait $APP_PID; exit" TERM INT

    # Monitor loop
    ELAPSED=0
    CHECK_INTERVAL=60  # Check every 60 seconds

    while [ $ELAPSED -lt $TTL ]; do
        # Check if application is still running
        if ! kill -0 $APP_PID 2>/dev/null; then
            echo "[TTL-WRAPPER] Application process $APP_PID exited unexpectedly"
            wait $APP_PID
            exit $?
        fi

        # Sleep for check interval or remaining time, whichever is shorter
        REMAINING=$((TTL - ELAPSED))
        SLEEP_TIME=$((REMAINING < CHECK_INTERVAL ? REMAINING : CHECK_INTERVAL))
        sleep $SLEEP_TIME
        ELAPSED=$((ELAPSED + SLEEP_TIME))
    done

    # TTL expired - initiate graceful shutdown
    echo "[TTL-WRAPPER] TTL expired after $TTL_HUMAN. Initiating graceful restart."
    echo "[TTL-WRAPPER] Sending SIGTERM to application (PID $APP_PID)"

    # Send SIGTERM for graceful shutdown
    kill -TERM $APP_PID 2>/dev/null || true

    # Wait for graceful shutdown with timeout
    SHUTDOWN_TIMEOUT=30
    SHUTDOWN_ELAPSED=0
    while [ $SHUTDOWN_ELAPSED -lt $SHUTDOWN_TIMEOUT ]; do
        if ! kill -0 $APP_PID 2>/dev/null; then
            echo "[TTL-WRAPPER] Application shut down gracefully"
            wait $APP_PID
            exit 0
        fi
        sleep 1
        SHUTDOWN_ELAPSED=$((SHUTDOWN_ELAPSED + 1))
    done

    # Force kill if graceful shutdown failed
    echo "[TTL-WRAPPER] Graceful shutdown timeout, sending SIGKILL"
    kill -KILL $APP_PID 2>/dev/null || true
    wait $APP_PID
    exit 0